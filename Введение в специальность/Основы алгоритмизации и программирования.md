### Управление компьютером при помощи программ: Теоретическая основа и архитектура

#Компьютер, как универсальная вычислительная машина (по опр. [[Алан Тьюринг (Alan Turing) | Алана Тьюринга]]), представляет собой устройство, способное выполнять произвольные алгоритмы при наличии подходящей программы. 

**Программа** - формализованная последовательность инструкций, предназначенная для управления ресурсы #ЭВМ (в данном случае компьютера). В научном смысле, управление при помощи программ реализуется через машинную модель Джона фон Неймана, где программы и данные хранятся в единой памяти, а процессор последовательно интерпретирует команды. 

С точки зрения архитектуры, программа сначала загружается в оперативную память, затем извлекается для выполнения, декодируется и исполняется процессором. Взаимодействие с программой осуществляется при помощи устройств ввода/вывода.

#### Роль ОС
#Ос выступает как посредник, абстрагируя аппаратные детали, лишь предоставляя интерфейсы ограниченного взаимодействия с ними. В терминах теории систем, ОС реализует виртуализацию ресурсов, позволяя нескольким программам работать параллельно. 


#### Вывод
Без программ, компьютер остаётся пассивным устройством, а программы наделяют его "интеллектом" через детерминированное выполнение. Т.е., на данный момент , именно пользователь, отталкиваясь от задачи, определяет исполнителя  и его характеристики.

### Понятие алгоритма: формальное определение и свойства
Алгоритм - абстрактная логически-математическая конструкция, представляющая собой конечную последовательность строго определённых шагов, приводящих от начального состояния (входных данных) к желаемому результату (выходным данным). Сам термин происходит от латинской транслитерации имени персидского математика Мухаммеда аль-Хорезми, жившего в 9 веке. Его труды заложили основу систематического решения уравнений. 

#### Основные свойства алгоритма
1. #Детерминированность (однозначность) - каждый шаг определяет уникальное действие для данного состояния.
2. #Массовость (общность) - алгоритм применим к классу задач, а не к одной конкретной.
3. #Результативность (эффективность) - гарантирует получение корректного результата.
4. #Дискретность - возможность разбиения алгоритма на атомарные (примитивные) операции.
5. #Конечность - любой алгоритм завершается за конечное число шагов.
6. #Корректность - результат соответствует ожидаемому и может быть проверен (доказан).
Также, алгоритмы поддаются следующему анализу:
- Временная сложность - мера количества вычислительных ресурсов (времени), необходимых для выполнения алгоритма в зависимости от входных данных.
- Пространственная сложность - мера объёма памяти, необходимого для выполнения алгоритма и выраженная как функция от размера входных данных.
- Средний случай
#### Big-O Notation (Нотация большой О)
![[Pasted image 20250929112421.png]]
Теги: #алгоритмы #BigO #сложность #программирование 

---

### Что такое Big O нотация?

Big O нотация ($O(...)$) используется для описания сложности алгоритмов, то есть для оценки того, как количество операций (время выполнения) зависит от размера входных данных ($N$).

Главная идея: Оценивается *худший* вариант развития событий (верхняя граница времени выполнения).

---

### Основные типы сложности

* $O(1)$ (Константное время / Order 1)
    * Описание: Количество операций не меняется при увеличении входных данных. Самый эффективный тип сложности.
    * Пример: Получение элемента массива по индексу array[0].

* $O(n)$ (Линейное время / Order n)
    * Описание: Количество операций растет прямо пропорционально размеру входных данных ($N$). Выполняется последовательно
    * Пример: Перебор всех элементов массива для поиска суммы.

* $O(n^2)$ (Квадратичное время / Order n квадрат)
    * Описание: Количество операций растет как квадрат размера входных данных. Неэффективно для больших $N$.
    * Пример: Вложенные циклы по одной и той же коллекции (например, для поиска дубликатов).

* $O(\log n)$ (Логарифмическое время / Order log n)
    * Описание: Количество операций растет очень медленно при увеличении $N$ (проблема делится пополам на каждом шаге). Очень эффективно.
    * Пример: Бинарный поиск (подход «Разделяй и властвуй», для отсортированных данных).

* $O(n \log n)$ (Линейно-логарифмическое время / Order n log n)
    * Описание: Сочетание линейного и логарифмического роста. Достаточно эффективный.
    * Пример: Эффективные алгоритмы сортировки, такие как Сортировка слиянием (Merge Sort) или Быстрая сортировка (Quick Sort).

---

### Правила Big O

1.  Константы отбрасываются: $O(3)$, $O(5)$ — это просто $O(1)$. $O(2n)$ или $O(n+5)$ — это просто $O(n)$. Фактическое количество шагов и младшие члены не важны.
2.  Доминирует худший член: В выражении $O(n^2 + n)$ доминирует $n^2$, поэтому сложность будет $O(n^2)$.

---

### Мышление в терминах Big O (Операция и Сложность)

* Получение элемента по индексу/ключу (массив, словарь/хеш-таблица): $O(1)$
* Перебор коллекции (один цикл): $O(n)$
* Вложенные циклы по одной коллекции: $O(n^2)$
* Разделение и завоевание (Divide and Conquer, например, бинарный поиск): $O(\log n)$
* Итерация с использованием Divide and Conquer: $O(n \log n)$
#### Классификация по структуре
1. Линейные, которые выполняются последовательно. #Линейность
2. С ветвлением, например, условные конструкции. #Ветвление
3. Циклические, в которых задействованы повторения. #Цикличность
4. Рекурсивные, в которых происходит обращение алгоритма к самому себе. #Рекурсивность